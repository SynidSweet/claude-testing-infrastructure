import { GapReportSchema, ActionableInsight, VisualizationConfig } from '../GapReportGenerator';

/**
 * Report Visualization Service - Creates ASCII art and visual formatting
 *
 * Focused service responsible for generating visual elements like ASCII art,
 * charts, and styled text reports.
 */
export class ReportVisualizationService {
  constructor(private visualConfig: VisualizationConfig = {}) {
    this.visualConfig = {
      terminalWidth: 80,
      useUnicode: true,
      colorScheme: 'default',
      ...visualConfig,
    };
  }

  /**
   * Generate plain text report with ASCII art
   */
  generateTextReport(schema: GapReportSchema): string {
    let report = `
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë       ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë       ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù 
   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë       ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     
   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     
                                                               
                 A N A L Y S I S   R E P O R T                
${'‚ïê'.repeat(this.visualConfig.terminalWidth || 80)}

Generated: ${schema.metadata.generatedAt}
Project: ${schema.metadata.projectPath}
Version: ${schema.metadata.version}`;

    if (schema.metadata.duration) {
      report += `
Duration: ${schema.metadata.duration}ms`;
    }

    report += `

EXECUTIVE SUMMARY
${'‚îÄ'.repeat(50)}
Total Files Analyzed           : ${schema.summary.totalFiles}
Files with Structural Tests    : ${schema.summary.filesWithTests}
Files Needing Logical Tests    : ${schema.summary.filesNeedingLogicalTests}
Total Gaps Identified         : ${schema.summary.totalGaps}
Overall Assessment            : ${schema.summary.overallAssessment.toUpperCase()}

COST ANALYSIS
${'‚îÄ'.repeat(50)}
AI Tasks Required             : ${schema.cost.numberOfTasks}
Estimated Tokens              : ${schema.cost.estimatedTokens.toLocaleString()}
Estimated Cost (USD)          : $${schema.cost.estimatedCostUSD}

PRIORITY BREAKDOWN
${'‚îÄ'.repeat(50)}`;

    Object.entries(schema.summary.priorityDistribution).forEach(([priority, count]) => {
      const paddedPriority = (priority.charAt(0).toUpperCase() + priority.slice(1)).padEnd(20);
      report += `
${paddedPriority} : ${count} files`;
    });

    report += `

IMMEDIATE ACTIONS
${'‚îÄ'.repeat(50)}`;
    schema.recommendations.immediate.forEach((rec, i) => {
      report += `
${(i + 1).toString().padStart(2)}. ${rec}`;
    });

    if (schema.recommendations.shortTerm.length > 0) {
      report += `

SHORT-TERM IMPROVEMENTS
${'‚îÄ'.repeat(50)}`;
      schema.recommendations.shortTerm.forEach((rec, i) => {
        report += `
${(i + 1).toString().padStart(2)}. ${rec}`;
      });
    }

    // Include top insights
    if (schema.insights.length > 0) {
      report += `

KEY INSIGHTS
${'‚îÄ'.repeat(50)}`;
      schema.insights.slice(0, 3).forEach((insight, i) => {
        report += `
${(i + 1).toString().padStart(2)}. ${insight.title}
    Impact: ${insight.impact.toUpperCase()} | Effort: ${insight.effort.toUpperCase()}
    ${insight.description}`;
      });
    }

    report += `

${'‚ïê'.repeat(this.visualConfig.terminalWidth || 80)}
Report generated by Claude Testing Infrastructure v${schema.metadata.version}
`;

    return report;
  }

  /**
   * Generate horizontal bar chart for priority distribution
   */
  generatePriorityChart(priorities: Record<string, number>): string {
    const maxCount = Math.max(...Object.values(priorities));
    const chartWidth = Math.min(
      40,
      this.visualConfig.terminalWidth ? this.visualConfig.terminalWidth - 30 : 50
    );

    let chart = '\nPriority Distribution:\n';
    chart += '‚îÄ'.repeat(chartWidth + 15) + '\n';

    Object.entries(priorities).forEach(([priority, count]) => {
      const barLength = Math.round((count / maxCount) * chartWidth);
      const bar = '‚ñà'.repeat(barLength) + '‚ñë'.repeat(chartWidth - barLength);
      const label = priority.charAt(0).toUpperCase() + priority.slice(1).padEnd(8);
      chart += `${label} ‚îÇ${bar}‚îÇ ${count}\n`;
    });

    return chart;
  }

  /**
   * Generate complexity distribution chart
   */
  generateComplexityChart(distribution: Record<string, number>): string {
    const maxCount = Math.max(...Object.values(distribution));
    const chartWidth = Math.min(
      40,
      this.visualConfig.terminalWidth ? this.visualConfig.terminalWidth - 30 : 50
    );

    let chart = '\nComplexity Distribution:\n';
    chart += '‚îÄ'.repeat(chartWidth + 20) + '\n';

    Object.entries(distribution).forEach(([complexity, count]) => {
      const barLength = Math.round((count / maxCount) * chartWidth);
      const bar = '‚ñì'.repeat(barLength) + '‚ñí'.repeat(chartWidth - barLength);
      const label = (complexity.charAt(0).toUpperCase() + complexity.slice(1)).padEnd(12);
      chart += `${label} ‚îÇ${bar}‚îÇ ${count}\n`;
    });

    return chart;
  }

  /**
   * Generate formatted table for summary data
   */
  generateSummaryTable(summary: GapReportSchema['summary']): string {
    const data = [
      ['Metric', 'Value', 'Status'],
      ['‚îÄ'.repeat(25), '‚îÄ'.repeat(10), '‚îÄ'.repeat(10)],
      ['Total Files Analyzed', summary.totalFiles.toString(), 'üìÅ'],
      ['Files with Tests', summary.filesWithTests.toString(), '‚úÖ'],
      [
        'Need Logical Tests',
        summary.filesNeedingLogicalTests.toString(),
        summary.filesNeedingLogicalTests > 0 ? '‚ö†Ô∏è' : '‚úÖ',
      ],
      ['Total Gaps', summary.totalGaps.toString(), this.getGapStatusIcon(summary.totalGaps)],
      [
        'Assessment',
        summary.overallAssessment.toUpperCase(),
        this.getAssessmentIcon(summary.overallAssessment),
      ],
    ];

    let table = '';
    data.forEach((row) => {
      table += `${row[0]?.padEnd(25) || ''} ‚îÇ ${row[1]?.padEnd(10) || ''} ‚îÇ ${row[2] || ''}\n`;
    });

    return table;
  }

  /**
   * Generate cost breakdown visualization
   */
  generateCostBreakdown(cost: GapReportSchema['cost']): string {
    let breakdown = `
üí∞ Cost Analysis
${'‚îÄ'.repeat(20)}
üéØ Tasks: ${cost.numberOfTasks}
ü™ô Tokens: ${cost.estimatedTokens.toLocaleString()}
üíµ Cost: $${cost.estimatedCostUSD}

`;

    if (Object.keys(cost.complexityDistribution).length > 0) {
      breakdown += this.generateComplexityChart(cost.complexityDistribution);
    }

    return breakdown;
  }

  /**
   * Generate insights summary with visual indicators
   */
  generateInsightsSummary(insights: ActionableInsight[]): string {
    if (insights.length === 0) return '';

    let summary = `
üß† Key Insights
${'‚îÄ'.repeat(16)}
`;

    insights.slice(0, 5).forEach((insight, i) => {
      const impactIcon =
        insight.impact === 'high' ? 'üî•' : insight.impact === 'medium' ? '‚ö°' : 'üí°';
      const effortIcon =
        insight.effort === 'low' ? 'üü¢' : insight.effort === 'medium' ? 'üü°' : 'üî¥';

      summary += `${i + 1}. ${impactIcon} ${insight.title}
   Impact: ${insight.impact.toUpperCase()} | Effort: ${insight.effort.toUpperCase()} ${effortIcon}
   ${insight.description.substring(0, 80)}${insight.description.length > 80 ? '...' : ''}

`;
    });

    return summary;
  }

  // Private utility methods for visualization elements

  private getGapStatusIcon(gapCount: number): string {
    if (gapCount === 0) return '‚úÖ';
    if (gapCount <= 5) return '‚ö†Ô∏è';
    if (gapCount <= 20) return '‚ùå';
    return 'üö®';
  }

  private getAssessmentIcon(assessment: string): string {
    const icons: Record<string, string> = {
      excellent: 'üèÜ',
      good: 'üëç',
      'needs-improvement': '‚ö†Ô∏è',
      poor: '‚ùå',
    };
    return icons[assessment] || '‚ùì';
  }

  /**
   * Generate progress bar for numeric values
   */
  generateProgressBar(current: number, max: number, width: number = 20): string {
    const percentage = Math.min(current / max, 1);
    const filled = Math.round(percentage * width);
    const empty = width - filled;

    return '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
  }

  /**
   * Generate sparkline for trend data
   */
  generateSparkline(values: number[]): string {
    if (values.length === 0) return '';

    const min = Math.min(...values);
    const max = Math.max(...values);
    const range = max - min;

    if (range === 0) return '‚îÄ'.repeat(values.length);

    const chars = ['‚ñÅ', '‚ñÇ', '‚ñÉ', '‚ñÑ', '‚ñÖ', '‚ñÜ', '‚ñá', '‚ñà'];

    return values
      .map((value) => {
        const normalized = (value - min) / range;
        const index = Math.floor(normalized * (chars.length - 1));
        return chars[index];
      })
      .join('');
  }
}
